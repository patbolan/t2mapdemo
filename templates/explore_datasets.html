<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Explore Datasets</title>
    <!-- Shared CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/shared.css') }}">
    <!-- Chart.js for interactive plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      /* Page-specific styles */
      body { 
        padding: 2rem;
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 { 
        margin-bottom: 1rem; 
        color: #333; 
      }
      
      /* Tab Navigation */
      .tab-container {
        margin: 2rem 0;
      }
      .tab-nav {
        display: flex;
        border-bottom: 2px solid #dee2e6;
        margin: 0;
        padding: 0;
        list-style: none;
      }
      .tab-nav li {
        margin: 0;
      }
      .tab-nav button {
        background: none;
        border: none;
        padding: 1rem 2rem;
        cursor: pointer;
        border-bottom: 3px solid transparent;
        transition: all 0.2s ease;
        white-space: nowrap;
        /* Card title styling inherited from shared.css */
      }
      .tab-nav button:hover {
        background: #f8f9fa;
      }
      .tab-nav button.active {
        border-bottom-color: var(--accent);
        background: #fff;
      }
      
      /* Tab Content */
      .tab-content {
        display: none;
        padding: 2rem 0;
        animation: fadeIn 0.3s ease-in;
      }
      .tab-content.active {
        display: block;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .dataset-card {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 2rem;
      }
      .dataset-title {
        margin: 0 0 1rem 0;
        color: #333;
        font-size: 1.5rem;
        border-bottom: 2px solid #dee2e6;
        padding-bottom: 0.5rem;
      }
      .dataset-description {
        margin: 1rem 0 2rem 0;
        line-height: 1.6;
        color: #555;
      }
      
      /* Images Grid */
      .images-grid {
        display: flex;
        gap: 2rem;
        margin: 2rem auto;
        max-width: 1400px;
        align-items: start;
      }
      
      /* Left side containers */
      .left-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }
      
      /* Maps container for S0 and T images */
      .maps-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.2rem;
      }
      
      /* Plot container for chart */
      .plot-container {
        flex: 1;
        background: #ffffff;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        min-height: 400px;
        padding: 1rem;
      }
      
      .chart-title {
        text-align: center;
        font-weight: bold;
        color: #555;
        margin-bottom: 1rem;
        font-size: 1.1em;
      }
      
      /* Detailed text container */
      .details-container {
        flex: 1;
        background: #d1d5db;
        border-radius: 8px;
        padding: 0.5rem;
        margin-top: 1rem;
        line-height: 1.6;
        color: #555;
      }
      
      /* Arrow container for process indication */
      .arrow-container {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        padding: 0.00rem 0;
        gap: 0.75rem;
      }
      
      .arrow-container .arrow {
        font-size: 3rem;
        font-weight: 900;
        color: var(--accent);
        line-height: 1;
      }
      
      .arrow-container .arrow-text {
        font-size: 0.9rem;
        font-weight: bold;
        color: var(--accent);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .image-container {
        text-align: center;
      }
      .image-container img {
        width: 100%;
        height: auto;
        border: 1px solid #ddd;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .image-title {
        margin: 0.5rem 0;
        font-weight: bold;
        color: #555;
      }
      
      /* Interactive image wrapper and crosshairs */
      .image-wrapper {
        position: relative;
        display: inline-block;
        cursor: none;
      }
      .image-wrapper img {
        border-radius: 6px;
      }
      .crosshair-overlay {
        position: absolute;
        pointer-events: none;
        display: none;
        z-index: 10;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
      }
      .crosshair-vertical {
        position: absolute;
        width: 1px;
        height: 100%;
        background-color: red;
        left: 50%;
      }
      .crosshair-horizontal {
        position: absolute;
        width: 100%;
        height: 1px;
        background-color: red;
        top: 50%;
      }
      .coord-display {
        text-align: center;
        font-size: 0.85em;
        color: #666;
        margin-top: 0.5rem;
        min-height: 1.2em;
      }
      .imageseries-container {
        text-align: center;
      }
      .imageseries-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 0.3rem;
      }
      
      .imageseries-grid .image-wrapper {
        position: relative;
        cursor: crosshair;
      }
      
      .imageseries-grid img {
        width: 100%;
        height: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }
      .imageseries-grid-title {
        text-align: center;
        font-weight: bold;
        color: #555;
        margin-bottom: 0.5rem;
        font-size: 0.95em;
      }
      
      /* Responsive */
      @media (max-width: 768px) {
        .tab-nav {
          flex-direction: column;
        }
        .tab-nav button {
          text-align: left;
          border-bottom: none;
          border-left: 3px solid transparent;
        }
        .tab-nav button.active {
          border-left-color: var(--accent);
          border-bottom-color: transparent;
        }
        .images-grid {
          flex-direction: column;
          gap: 1rem;
        }
        .maps-container {
          grid-template-columns: 1fr;
        }
        .plot-container {
          min-height: 200px;
        }
      }
    </style>
  </head>
  <body>
    <a href="/" class="back-link">← Back to Home</a>
    
    <h1>Representative Datasets</h1>
    
    <div class="info-box">
      <p><strong>About the Datasets</strong></p>
      <p>This page provides an interactive display for exploring the three sample datasets shown in 
        <a href="https://link.springer.com/article/10.1007/s10334-024-01186-3/figures/1">Figure 1</a> 
        of the paper. Click the tabs below to explore all three.</p>   
    </div>

    <div class="tab-container">
      <!-- Tab Navigation -->
      <ul class="tab-nav">
        <li><button class="tab-btn active" data-tab="invivo">In Vivo Dataset</button></li>
        <li><button class="tab-btn" data-tab="imagenet">ImageNet Synthetic</button></li>
        <li><button class="tab-btn" data-tab="random">Random Synthetic</button></li>
      </ul>

      <!-- Tab Content: Single Dynamic Template -->
      <div class="tab-content active" id="dynamic-content">
        <div class="dataset-card">
          <h2 class="dataset-title" id="dataset-title"><!-- Dynamic Title --></h2>
          <div class="dataset-description">
            <p id="dataset-description"><!-- Dynamic Description --></p>
          </div>
          
          <div class="images-grid" id="images-container" style="display: none;">
            <div class="left-container">
              <div class="maps-container">
                <div class="image-container">
                  <div class="image-title">
                    <div style="font-size: 1.1em;">S0 Parameter</div>
                    <div style="font-size: 0.9em;" id="s0-subtitle"><!-- Dynamic Subtitle --></div>
                  </div>
                  <div class="image-wrapper" id="s0-param-wrapper">
                    <img id="s0-image" src="" alt="">
                    <div class="crosshair-overlay" id="s0-crosshair">
                      <div class="crosshair-vertical"></div>
                      <div class="crosshair-horizontal"></div>
                    </div>
                  </div>
                  <div class="coord-display" id="s0-coord-display"></div>
                </div>
                
                <div class="image-container">
                  <div class="image-title">
                    <div style="font-size: 1.1em;">T Parameter</div>
                    <div style="font-size: 0.9em;" id="t-subtitle"><!-- Dynamic Subtitle --></div>
                  </div>
                  <div class="image-wrapper" id="t-param-wrapper">
                    <img id="t-image" src="" alt="">
                    <div class="crosshair-overlay" id="t-crosshair">
                      <div class="crosshair-vertical"></div>
                      <div class="crosshair-horizontal"></div>
                    </div>
                  </div>
                  <div class="coord-display" id="t-coord-display"></div>
                </div>
                </div>

                <div class="arrow-container">
                  <div class="arrow" id="arrow-symbol"><!-- Dynamic Arrow --></div>
                  <div class="arrow-text" id="arrow-text"><!-- Dynamic Text --></div>
                </div>

              <div class="imageseries-container">
                <div class="imageseries-grid-title" id="imageseries-title"><!-- Dynamic Image Series Title --></div>
                <div class="imageseries-grid" id="imageseries-grid">
                  <!-- Dynamic echo images -->
                </div>
              </div>
            </div>
            
            <div style="flex: 1; display: flex; flex-direction: column;">
              <div class="plot-container">
                <div class="chart-title" id="chart-title">Signal Decay Curve at Pixel (50, 50)</div>
                <canvas id="signalChart"></canvas>
              </div>
              
              <div class="details-container">
                <p id="details-text">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
              </div>
            </div>
          </div>
          
          <p id="no-images-message" style="text-align: center; color: #666; display: none;">Images not available.</p>
        </div>
      </div>
    </div>

    <!-- Image data injection -->
    <script id="invivo-data" type="application/json">{% if invivo_images %}{{ invivo_images | tojson | safe }}{% else %}null{% endif %}</script>
    <script id="imagenet-data" type="application/json">{% if imagenet_images %}{{ imagenet_images | tojson | safe }}{% else %}null{% endif %}</script>
    <script id="random-data" type="application/json">{% if urand_images %}{{ urand_images | tojson | safe }}{% else %}null{% endif %}</script>
    <script id="te-values" type="application/json">{% if TE_vals %}{{ TE_vals | tojson | safe }}{% else %}null{% endif %}</script>

    <script>
    // Dataset configuration
    const datasetConfig = {
      invivo: {
        title: 'In Vivo Dataset',
        description: 'Below are the reference parametric maps for S0 and T parameters from an in vivo case (000198).',
        s0Subtitle: 'Reference (Labels)',
        tSubtitle: 'Reference (Labels)',
        imageseriesTitle: 'Multi-Echo Image Series',
        s0Alt: 'In Vivo S0',
        tAlt: 'In Vivo T',
        echoAltPrefix: 'Echo',
        arrowDirection: 'up',
        arrowText: 'curve fit',
        detailsText: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.'
      },
      imagenet: {
        title: 'ImageNet Synthetic Dataset',
        description: 'Below are the reference (ground truth) parametric maps for S0 and T parameters from case 000066 using ImageNet-based synthetic data.',
        s0Subtitle: 'Ground Truth',
        tSubtitle: 'Ground Truth',
        imageseriesTitle: 'Synthetic Multi-Echo Series',
        s0Alt: 'ImageNet S0',
        tAlt: 'ImageNet T',
        echoAltPrefix: 'Synth',
        arrowDirection: 'down',
        arrowText: 'synthesize',
        detailsText: 'Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam eaque ipsa. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit. At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium.'
      },
      random: {
        title: 'Random Synthetic Dataset',
        description: 'Below are the reference (ground truth) parametric maps for S0 and T parameters from case 000066 using randomly generated synthetic data.',
        s0Subtitle: 'Ground Truth',
        tSubtitle: 'Ground Truth',
        imageseriesTitle: 'Synthetic Multi-Echo Series',
        s0Alt: 'Random S0',
        tAlt: 'Random T',
        echoAltPrefix: 'Random',
        arrowDirection: 'down',
        arrowText: 'synthesize',
        detailsText: 'But I must explain to you how all this mistaken idea of denouncing pleasure and praising pain was born. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium.'
      }
    };

    // Global variables for chart and current dataset
    let signalChart = null;
    let currentDatasetKey = 'invivo';
    let currentImageArrays = [];
    let currentS0Array = [];
    let currentTArray = [];
    let imageWidth = 0;
    let imageHeight = 0;
    
    // Configuration flag for image series interactivity
    let enableImageSeriesInteractivity = true;

    // Load image data from script tags
    function getImageData(datasetKey) {
      const scriptId = `${datasetKey}-data`;
      const script = document.getElementById(scriptId);
      if (script && script.textContent.trim() !== 'null') {
        return JSON.parse(script.textContent);
      }
      return null;
    }

    // Load TE values from script tag
    function getTEValues() {
      const script = document.getElementById('te-values');
      if (script && script.textContent.trim() !== 'null') {
        return JSON.parse(script.textContent);
      }
      // Fallback to indices if TE values not available
      return Array.from({length: 10}, (_, i) => i);
    }

    // Decode base64 image to ImageData array
    function decodeImageToArray(base64ImageData) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          const imageData = ctx.getImageData(0, 0, img.width, img.height);
          resolve(imageData);
        };
        img.src = `data:image/png;base64,${base64ImageData}`;
      });
    }

    // Convert ImageData to normalized array (0-1 values)
    function imageDataToNormalizedArray(imageData) {
      const array = [];
      for (let y = 0; y < imageData.height; y++) {
        const row = [];
        for (let x = 0; x < imageData.width; x++) {
          const pixelIndex = (y * imageData.width + x) * 4;
          const grayValue = imageData.data[pixelIndex]; // R channel of RGBA
          row.push(grayValue / 255.0); // Normalize to 0-1
        }
        array.push(row);
      }
      return array;
    }

    // Initialize Chart.js
    function initializeChart() {
      const ctx = document.getElementById('signalChart').getContext('2d');
      
      // Get actual TE values
      const teValues = getTEValues();
      
      // Initial data (will be updated when mouse moves)
      const initialData = teValues.map(te => ({ x: te, y: 0 }));
      
      signalChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'Measured Signal',
            data: initialData,
            backgroundColor: 'rgba(54, 162, 235, 0.8)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6,
            showLine: true,
            tension: 0
          }, {
            label: 'Fitted Curve: S₀×exp(-TE/T₂)',
            data: initialData.map(point => ({ ...point })), // Copy initial data
            backgroundColor: 'rgba(255, 99, 132, 0.8)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 2,
            pointRadius: 2,
            pointHoverRadius: 4,
            showLine: true,
            tension: 0,
            borderDash: [5, 5] // Dashed line to distinguish from measured data
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 1.33,
          plugins: {
            legend: {
              display: true,
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `TE: ${context.parsed.x.toFixed(1)} ms, Signal: ${context.parsed.y.toFixed(4)}`;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              min: 0,
              max: 150,
              ticks: {
                stepSize: 25
              },
              title: {
                display: true,
                text: 'Echo Time (ms)',
                font: { size: 14, weight: 'bold' }
              },
              grid: { display: true, color: 'rgba(0, 0, 0, 0.1)' }
            },
            y: {
              title: {
                display: true,
                text: 'Signal Intensity',
                font: { size: 14, weight: 'bold' }
              },
              grid: { display: true, color: 'rgba(0, 0, 0, 0.1)' },
              beginAtZero: true,
              min: 0,
              max: 1.0
            }
          }
        }
      });
    }

    // Calculate fitted exponential curve S(TE) = S0 * exp(-TE/T2)
    function calculateFittedCurve(s0Value, t2Value, teValues, images) {
      if (s0Value === null || t2Value === null || t2Value <= 0 || !images) {
        // Return zeros if invalid parameters
        return teValues.map(te => ({ x: te, y: 0 }));
      }
      
      // Get scale factors from the dataset, with fallbacks
      const s0ScaleFactor = images.label_S0_scale_factor || 1; // Default to invivo scale
      const t2ScaleFactor = images.label_T_scale_factor || 1;     // Default to invivo scale
      const imageScaleFactor = images.images_scale_factor || 1; // Default to invivo scale
      
      // Convert T2 value back to original scale using dataset-specific factor
      const t2Scaled = t2Value / t2ScaleFactor; // Convert from normalized back to original units
      
      // Convert S0 value back to original scale using dataset-specific factor  
      const s0Scaled = s0Value / s0ScaleFactor * imageScaleFactor; // Convert from normalized back to original units
      
      // Print all these values out to the console for debugging
      console.log(`S0 Value: ${s0Value}, T2 Value: ${t2Value}`);
      console.log(`S0 Scaled: ${s0Scaled}, T2 Scaled: ${t2Scaled}`);  
      console.log(`Scale Factors - S0: ${s0ScaleFactor}, T2: ${t2ScaleFactor}, Image: ${imageScaleFactor}`);


      return teValues.map(te => ({
        x: te,
        y: s0Scaled * Math.exp(-te / (t2Scaled * 1000)) // T2 in seconds, TE in ms
      }));
    }

    // Update chart with new pixel data
    function updateChart(imgX, imgY) {
      if (!signalChart || currentImageArrays.length === 0 || 
          imgX < 0 || imgY < 0 || 
          imgX >= imageWidth || imgY >= imageHeight) {
        return;
      }
      
      // Get actual TE values
      const teValues = getTEValues();
      
      // Extract values at coordinates from all image series
      const measuredData = teValues.map((te, idx) => {
        if (idx < currentImageArrays.length && 
            imgY < currentImageArrays[idx].length && 
            imgX < currentImageArrays[idx][imgY].length) {
          return { x: te, y: currentImageArrays[idx][imgY][imgX] };
        }
        return { x: te, y: 0 };
      });
      
      // Get S0 and T2 values at this pixel location
      const s0Value = getPixelValue(currentS0Array, imgX, imgY);
      const t2Value = getPixelValue(currentTArray, imgX, imgY);
      
      // Get current dataset images for scale factors
      const images = getImageData(currentDatasetKey);
      
      // Calculate fitted curve using dataset-specific scale factors
      const fittedData = calculateFittedCurve(s0Value, t2Value, teValues, images);
      
      // Update chart data
      signalChart.data.datasets[0].data = measuredData; // Measured signal
      signalChart.data.datasets[1].data = fittedData;   // Fitted curve
      signalChart.update('none');
      
      // Update chart title
      document.getElementById('chart-title').textContent = `Signal Decay at Pixel (${imgX}, ${imgY})`;
    }

    // Get pixel value from array at coordinates
    function getPixelValue(imageArray, x, y) {
      if (imageArray.length === 0 || 
          y < 0 || y >= imageArray.length || 
          x < 0 || x >= imageArray[0].length) {
        return null;
      }
      return imageArray[y][x];
    }

    // Handle mouse movement on any interactive image
    function handleMouseMove(e, sourceWrapper, sourceImage, allCrosshairs, allCoordDisplays) {
      const rect = sourceImage.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Convert to image pixel coordinates
      const imgX = Math.floor((x / rect.width) * imageWidth);
      const imgY = Math.floor((y / rect.height) * imageHeight);
      
      // Only update S0 and T crosshairs (first two in the array)
      const parameterCrosshairs = allCrosshairs.slice(0, 2);
      parameterCrosshairs.forEach((crosshair, index) => {
        if (crosshair) {
          const targetImage = index === 0 ? 
            document.getElementById('s0-image') : 
            document.getElementById('t-image');
          
          if (targetImage) {
            const targetRect = targetImage.getBoundingClientRect();
            const targetX = (imgX / imageWidth) * targetRect.width;
            const targetY = (imgY / imageHeight) * targetRect.height;
            
            const vertical = crosshair.querySelector('.crosshair-vertical');
            const horizontal = crosshair.querySelector('.crosshair-horizontal');
            vertical.style.left = targetX + 'px';
            horizontal.style.top = targetY + 'px';
            crosshair.style.display = 'block';
          }
        }
      });
      
      // Get pixel values for S0 and T images
      const s0Value = getPixelValue(currentS0Array, imgX, imgY);
      const tValue = getPixelValue(currentTArray, imgX, imgY);
      
      // Update coordinate displays with pixel coordinates and values
      const s0Display = document.getElementById('s0-coord-display');
      const tDisplay = document.getElementById('t-coord-display');
      
      if (s0Display) {
        const s0Text = s0Value !== null ? 
          `(${imgX}, ${imgY}): ${(s0Value * 255).toFixed(0)}` : 
          `(${imgX}, ${imgY}): --`;
        s0Display.textContent = s0Text;
      } 
      if (tDisplay) {
        const tText = tValue !== null ? 
          `(${imgX}, ${imgY}): ${(tValue * 255).toFixed(0)}` : 
          `(${imgX}, ${imgY}): --`;
        tDisplay.textContent = tText;
      }
      // Update chart
      updateChart(imgX, imgY);
    }
    
    // Hide all crosshairs and clear coordinate displays
    function hideAllCrosshairs(allCrosshairs, allCoordDisplays) {
      // Only hide S0 and T crosshairs (first two in the array)
      const parameterCrosshairs = allCrosshairs.slice(0, 2);
      parameterCrosshairs.forEach(crosshair => {
        if (crosshair) {
          crosshair.style.display = 'none';
        }
      });
      
      // Set placeholder text to maintain layout
      const s0Display = document.getElementById('s0-coord-display');
      const tDisplay = document.getElementById('t-coord-display');
      
      if (s0Display) {
        s0Display.textContent = ' '; // Single space placeholder
      }
      if (tDisplay) {
        tDisplay.textContent = ' '; // Single space placeholder
      }
    }

    // Set up mouse event listeners for all interactive images
    function setupMouseListeners() {
      // Get parameter image elements
      const s0Wrapper = document.getElementById('s0-param-wrapper');
      const s0Image = document.getElementById('s0-image');
      const s0Crosshair = document.getElementById('s0-crosshair');
      const s0CoordDisplay = document.getElementById('s0-coord-display');
      
      const tWrapper = document.getElementById('t-param-wrapper');
      const tImage = document.getElementById('t-image');
      const tCrosshair = document.getElementById('t-crosshair');
      const tCoordDisplay = document.getElementById('t-coord-display');
      
      // Get all image series elements
      const imageSeriesWrappers = document.querySelectorAll('.imageseries-grid .image-wrapper');
      
      // Collect only parameter crosshairs and coordinate displays
      const allCrosshairs = [s0Crosshair, tCrosshair];
      const allCoordDisplays = [s0CoordDisplay, tCoordDisplay];
      
      if (s0Wrapper && tWrapper) {
        // Parameter image mouse events
        [s0Wrapper, tWrapper].forEach(wrapper => {
          const image = wrapper.querySelector('img');
          
          wrapper.addEventListener('mousemove', function(e) {
            handleMouseMove(e, wrapper, image, allCrosshairs, allCoordDisplays);
          });
          
          wrapper.addEventListener('mouseleave', function() {
            hideAllCrosshairs(allCrosshairs, allCoordDisplays);
          });
        });
      }
      
      // Image series mouse events (only if enabled) - no crosshairs, just cursor and chart updates
      if (enableImageSeriesInteractivity) {
        imageSeriesWrappers.forEach((wrapper, index) => {
          const image = wrapper.querySelector('img');
          
          if (image) {
            wrapper.addEventListener('mousemove', function(e) {
              handleMouseMove(e, wrapper, image, allCrosshairs, allCoordDisplays);
            });
            
            wrapper.addEventListener('mouseleave', function() {
              hideAllCrosshairs(allCrosshairs, allCoordDisplays);
            });
          }
        });
      }
    }

    // Process image series data for current dataset
    async function processImageSeries(images) {
      currentImageArrays = [];
      currentS0Array = [];
      currentTArray = [];
      
      // Process S0 and T parameter maps
      if (images.label_S0) {
        try {
          const s0ImageData = await decodeImageToArray(images.label_S0);
          currentS0Array = imageDataToNormalizedArray(s0ImageData);
        } catch (error) {
          console.error('Error processing S0 image:', error);
        }
      }
      
      if (images.label_T) {
        try {
          const tImageData = await decodeImageToArray(images.label_T);
          currentTArray = imageDataToNormalizedArray(tImageData);
        } catch (error) {
          console.error('Error processing T image:', error);
        }
      }
      
      // Decode all image_* arrays
      for (let i = 0; i < 10; i++) {
        const imageKey = `image_${i}`;
        if (images[imageKey]) {
          try {
            const imageData = await decodeImageToArray(images[imageKey]);
            const normalizedArray = imageDataToNormalizedArray(imageData);
            currentImageArrays.push(normalizedArray);
            
            // Set dimensions from first image
            if (i === 0) {
              imageWidth = imageData.width;
              imageHeight = imageData.height;
            }
          } catch (error) {
            console.error(`Error processing image_${i}:`, error);
            currentImageArrays.push([]);
          }
        }
      }
    }

    // Function to update the content based on selected dataset
    async function updateContent(datasetKey) {
      currentDatasetKey = datasetKey;
      const config = datasetConfig[datasetKey];
      const images = getImageData(datasetKey);
      
      // Update text content
      document.getElementById('dataset-title').textContent = config.title;
      document.getElementById('dataset-description').textContent = config.description;
      document.getElementById('s0-subtitle').textContent = config.s0Subtitle;
      document.getElementById('t-subtitle').textContent = config.tSubtitle;
      document.getElementById('imageseries-title').textContent = config.imageseriesTitle;
      document.getElementById('details-text').textContent = config.detailsText;
      
      // Update arrow direction and text
      const arrowSymbol = document.getElementById('arrow-symbol');
      const arrowText = document.getElementById('arrow-text');
      arrowSymbol.textContent = config.arrowDirection === 'up' ? '↑' : '↓';
      arrowText.textContent = config.arrowText;
      
      const imagesContainer = document.getElementById('images-container');
      const noImagesMessage = document.getElementById('no-images-message');
      
      if (images) {
        // Show images container, hide no-images message
        imagesContainer.style.display = 'flex';
        noImagesMessage.style.display = 'none';
        
        // Update S0 and T images
        const s0Image = document.getElementById('s0-image');
        const tImage = document.getElementById('t-image');
        
        s0Image.src = `data:image/png;base64,${images.label_S0}`;
        s0Image.alt = config.s0Alt;
        
        tImage.src = `data:image/png;base64,${images.label_T}`;
        tImage.alt = config.tAlt;
        
        // Update image series grid images
        const imageseriesGrid = document.getElementById('imageseries-grid');
        imageseriesGrid.innerHTML = '';
        
        for (let i = 0; i < 10; i++) {
          const imageKey = `image_${i}`;
          if (images[imageKey]) {
            // Create wrapper div (no crosshair overlay for echo series)
            const wrapper = document.createElement('div');
            wrapper.className = 'image-wrapper';
            
            // Create image element
            const img = document.createElement('img');
            img.src = `data:image/png;base64,${images[imageKey]}`;
            img.alt = `${config.echoAltPrefix} ${i}`;
            
            wrapper.appendChild(img);
            imageseriesGrid.appendChild(wrapper);
          }
        }
        
        // Process image series for interactive plotting
        await processImageSeries(images);
        
        // Setup mouse listeners after images are loaded
        setTimeout(setupMouseListeners, 100);
        
      } else {
        // Hide images container, show no-images message
        imagesContainer.style.display = 'none';
        noImagesMessage.style.display = 'block';
        currentImageArrays = [];
      }
    }

    // Function to toggle image series interactivity
    function toggleImageSeriesInteractivity(enabled) {
      enableImageSeriesInteractivity = enabled;
      // Re-setup mouse listeners with new setting
      if (currentDatasetKey) {
        setTimeout(setupMouseListeners, 100);
      }
    }

    // Tab switching functionality
    document.querySelectorAll('.tab-btn').forEach(button => {
      button.addEventListener('click', () => {
        const tabId = button.getAttribute('data-tab');
        
        // Remove active class from all tabs
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        
        // Add active class to clicked tab
        button.classList.add('active');
        
        // Update content based on selected tab
        updateContent(tabId);
      });
    });

    // Initialize everything when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      initializeChart();
            
      updateContent('invivo');
    });

    // Expose toggle function globally for external control
    window.toggleImageSeriesInteractivity = toggleImageSeriesInteractivity;
    </script>

  </body>
</html>
