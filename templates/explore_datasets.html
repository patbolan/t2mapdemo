<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Explore Datasets</title>
    <!-- Shared CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/shared.css') }}">
    <!-- Chart.js for interactive plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      /* Page-specific styles */
      body { 
        padding: 2rem;
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 { 
        margin-bottom: 1rem; 
        color: #333; 
      }
      
      /* Tab Navigation */
      .tab-container {
        margin: 2rem 0;
      }
      .tab-nav {
        display: flex;
        border-bottom: 2px solid #dee2e6;
        margin: 0;
        padding: 0;
        list-style: none;
      }
      .tab-nav li {
        margin: 0;
      }
      .tab-nav button {
        background: none;
        border: none;
        padding: 1rem 2rem;
        cursor: pointer;
        border-bottom: 3px solid transparent;
        transition: all 0.2s ease;
        white-space: nowrap;
        /* Card title styling inherited from shared.css */
      }
      .tab-nav button:hover {
        background: #f8f9fa;
      }
      .tab-nav button.active {
        border-bottom-color: var(--accent);
        background: #fff;
      }
      
      /* Tab Content */
      .tab-content {
        display: none;
        padding: 2rem 0;
        animation: fadeIn 0.3s ease-in;
      }
      .tab-content.active {
        display: block;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .dataset-card {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 2rem;
      }
      .dataset-title {
        margin: 0 0 1rem 0;
        color: #333;
        font-size: 1.5rem;
        border-bottom: 2px solid #dee2e6;
        padding-bottom: 0.5rem;
      }
      .dataset-description {
        margin: 1rem 0 2rem 0;
        line-height: 1.6;
        color: #555;
      }
      
      /* Images Grid */
      .images-grid {
        display: flex;
        gap: 2rem;
        margin: 2rem auto;
        max-width: 1400px;
        align-items: start;
      }
      
      /* Left side containers */
      .left-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }
      
      /* Maps container for S0 and T images */
      .maps-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.2rem;
      }
      
      /* Plot container for chart */
      .plot-container {
        flex: 1;
        background: #ffffff;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        min-height: 400px;
        padding: 1rem;
      }
      
      .chart-title {
        text-align: center;
        font-weight: bold;
        color: #555;
        margin-bottom: 1rem;
        font-size: 1.1em;
      }
      
      /* Detailed text container */
      .details-container {
        flex: 1;
        background: #d1d5db;
        border-radius: 8px;
        padding: 0.5rem;
        margin-top: 1rem;
        line-height: 1.6;
        color: #555;
      }
      
      /* Arrow container for process indication */
      .arrow-container {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        padding: 0.00rem 0;
        gap: 0.75rem;
      }
      
      .arrow-container .arrow {
        font-size: 3rem;
        font-weight: 900;
        color: var(--accent);
        line-height: 1;
      }
      
      .arrow-container .arrow-text {
        font-size: 0.9rem;
        font-weight: bold;
        color: var(--accent);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .image-container {
        text-align: center;
      }
      .image-container img {
        width: 100%;
        height: auto;
        border: 1px solid #ddd;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .image-title {
        margin: 0.5rem 0;
        font-weight: bold;
        color: #555;
      }
      
      /* Interactive image wrapper and crosshairs */
      .image-wrapper {
        position: relative;
        display: block;
        width: 100%;
        cursor: none;
      }
      .image-wrapper img {
        display: block;
        width: 100%;
        height: auto;
        border-radius: 6px;
      }
      .crosshair-overlay {
        position: absolute;
        pointer-events: none;
        display: none;
        z-index: 10;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
      }
      .crosshair-vertical {
        position: absolute;
        width: 1px;
        height: 100%;
        background-color: red;
        left: 50%;
      }
      .crosshair-horizontal {
        position: absolute;
        width: 100%;
        height: 1px;
        background-color: red;
        top: 50%;
      }
      .coord-display {
        text-align: center;
        font-size: 0.85em;
        color: #666;
        margin-top: 0.5rem;
        min-height: 1.2em;
      }
      .imageseries-container {
        text-align: center;
      }
      .imageseries-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 0.3rem;
      }
      .imageseries-grid img {
        width: 100%;
        height: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }
      .imageseries-grid-title {
        text-align: center;
        font-weight: bold;
        color: #555;
        margin-bottom: 0.5rem;
        font-size: 0.95em;
      }
      
      /* Responsive */
      @media (max-width: 768px) {
        .tab-nav {
          flex-direction: column;
        }
        .tab-nav button {
          text-align: left;
          border-bottom: none;
          border-left: 3px solid transparent;
        }
        .tab-nav button.active {
          border-left-color: var(--accent);
          border-bottom-color: transparent;
        }
        .images-grid {
          flex-direction: column;
          gap: 1rem;
        }
        .maps-container {
          grid-template-columns: 1fr;
        }
        .plot-container {
          min-height: 200px;
        }
      }
    </style>
  </head>
  <body>
    <a href="/" class="back-link">← Back to Home</a>
    
    <h1>Representative Datasets</h1>
    
    <div class="info-box">
      <p><strong>About the Datasets</strong></p>
      <p>This page provides an interactive display for exploring the three sample datasets shown in 
        <a href="https://link.springer.com/article/10.1007/s10334-024-01186-3/figures/1">Figure 1</a> 
        of the paper. Click the tabs below to explore all three.</p>   
    </div>

    <div class="tab-container">
      <!-- Tab Navigation -->
      <ul class="tab-nav">
        <li><button class="tab-btn active" data-tab="invivo">In Vivo Dataset</button></li>
        <li><button class="tab-btn" data-tab="imagenet">ImageNet Synthetic</button></li>
        <li><button class="tab-btn" data-tab="random">Random Synthetic</button></li>
      </ul>

      <!-- Tab Content: Single Dynamic Template -->
      <div class="tab-content active" id="dynamic-content">
        <div class="dataset-card">
          <h2 class="dataset-title" id="dataset-title"><!-- Dynamic Title --></h2>
          <div class="dataset-description">
            <p id="dataset-description"><!-- Dynamic Description --></p>
          </div>
          
          <div class="images-grid" id="images-container" style="display: none;">
            <div class="left-container">
              <div class="maps-container">
                <div class="image-container">
                  <div class="image-title">
                    <div style="font-size: 1.1em;">S0 Parameter</div>
                    <div style="font-size: 0.9em;" id="s0-subtitle"><!-- Dynamic Subtitle --></div>
                  </div>
                  <div class="image-wrapper" id="s0-param-wrapper">
                    <img id="s0-image" src="" alt="">
                    <div class="crosshair-overlay" id="s0-crosshair">
                      <div class="crosshair-vertical"></div>
                      <div class="crosshair-horizontal"></div>
                    </div>
                  </div>
                  <div class="coord-display" id="s0-coord-display"></div>
                </div>
                
                <div class="image-container">
                  <div class="image-title">
                    <div style="font-size: 1.1em;">T Parameter</div>
                    <div style="font-size: 0.9em;" id="t-subtitle"><!-- Dynamic Subtitle --></div>
                  </div>
                  <div class="image-wrapper" id="t-param-wrapper">
                    <img id="t-image" src="" alt="">
                    <div class="crosshair-overlay" id="t-crosshair">
                      <div class="crosshair-vertical"></div>
                      <div class="crosshair-horizontal"></div>
                    </div>
                  </div>
                  <div class="coord-display" id="t-coord-display"></div>
                </div>
                </div>

                <div class="arrow-container">
                  <div class="arrow" id="arrow-symbol"><!-- Dynamic Arrow --></div>
                  <div class="arrow-text" id="arrow-text"><!-- Dynamic Text --></div>
                </div>

              <div class="imageseries-container">
                <div class="imageseries-grid-title" id="imageseries-title"><!-- Dynamic Image Series Title --></div>
                <div class="imageseries-grid" id="imageseries-grid">
                  <!-- Dynamic echo images -->
                </div>
              </div>
            </div>
            
            <div style="flex: 1; display: flex; flex-direction: column;">
              <div class="plot-container">
                <div class="chart-title" id="chart-title">Signal Decay Curve at Pixel (50, 50)</div>
                <canvas id="signalChart"></canvas>
              </div>
              
              <div class="details-container">
                <p id="details-text">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
              </div>
            </div>
          </div>
          
          <p id="no-images-message" style="text-align: center; color: #666; display: none;">Images not available.</p>
        </div>
      </div>
    </div>

    <!-- Image data injection -->
    <script id="invivo-data" type="application/json">{% if invivo_imageset %}{{ invivo_imageset | tojson | safe }}{% else %}null{% endif %}</script>
    <script id="imagenet-data" type="application/json">{% if imagenet_imageset %}{{ imagenet_imageset | tojson | safe }}{% else %}null{% endif %}</script>
    <script id="random-data" type="application/json">{% if urand_imageset %}{{ urand_imageset | tojson | safe }}{% else %}null{% endif %}</script>
    <script id="te-vals-data" type="application/json">{% if TE_vals %}{{ TE_vals | tojson | safe }}{% else %}null{% endif %}</script>

    <script>
    // Load TE values
    const TE_vals = JSON.parse(document.getElementById('te-vals-data').textContent) || [26.4, 39.6, 52.8, 66.0, 79.2, 92.4, 105.6, 118.8, 132.0, 145.2];
    
    // Dataset configuration
    const datasetConfig = {
      invivo: {
        title: 'In Vivo Dataset',
        description: 'Below are the reference parametric maps for S0 and T parameters from an in vivo case (000198).',
        s0Subtitle: 'Reference (Labels)',
        tSubtitle: 'Reference (Labels)',
        imageseriesTitle: 'Multi-Echo Image Series',
        s0Alt: 'In Vivo S0',
        tAlt: 'In Vivo T',
        echoAltPrefix: 'Echo',
        arrowDirection: 'up',
        arrowText: 'curve fit',
        detailsText: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.'
      },
      imagenet: {
        title: 'ImageNet Synthetic Dataset',
        description: 'Below are the reference (ground truth) parametric maps for S0 and T parameters from case 000066 using ImageNet-based synthetic data.',
        s0Subtitle: 'Ground Truth',
        tSubtitle: 'Ground Truth',
        imageseriesTitle: 'Synthetic Multi-Echo Series',
        s0Alt: 'ImageNet S0',
        tAlt: 'ImageNet T',
        echoAltPrefix: 'Synth',
        arrowDirection: 'down',
        arrowText: 'synthesize',
        detailsText: 'Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam eaque ipsa. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit. At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium.'
      },
      random: {
        title: 'Random Synthetic Dataset',
        description: 'Below are the reference (ground truth) parametric maps for S0 and T parameters from case 000066 using randomly generated synthetic data.',
        s0Subtitle: 'Ground Truth',
        tSubtitle: 'Ground Truth',
        imageseriesTitle: 'Synthetic Multi-Echo Series',
        s0Alt: 'Random S0',
        tAlt: 'Random T',
        echoAltPrefix: 'Random',
        arrowDirection: 'down',
        arrowText: 'synthesize',
        detailsText: 'But I must explain to you how all this mistaken idea of denouncing pleasure and praising pain was born. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium.'
      }
    };

    // Global variables for chart and current dataset
    let signalChart = null;
    let currentDatasetKey = 'invivo';
    let currentImageArrays = [];
    let imageWidth = 0;
    let imageHeight = 0;

    // Load image data from script tags
    function getImageData(datasetKey) {
      const scriptId = `${datasetKey}-data`;
      const script = document.getElementById(scriptId);
      if (script && script.textContent.trim() !== 'null') {
        return JSON.parse(script.textContent);
      }
      return null;
    }

    // Viridis colormap lookup table (256 entries)
    const viridisColors = [[68,1,84],[68,2,86],[69,4,87],[69,5,89],[70,7,90],[70,8,92],[70,10,93],[70,11,94],[71,13,96],[71,14,97],[71,16,99],[71,17,100],[71,19,101],[72,20,103],[72,22,104],[72,23,105],[72,24,106],[72,26,108],[72,27,109],[72,28,110],[72,29,111],[72,31,112],[72,32,113],[72,33,115],[72,35,116],[72,36,117],[72,37,118],[72,38,119],[72,40,120],[72,41,121],[71,42,122],[71,44,122],[71,45,123],[71,46,124],[71,47,125],[70,48,126],[70,50,126],[70,51,127],[70,52,128],[69,53,129],[69,55,129],[69,56,130],[68,57,131],[68,58,131],[68,59,132],[67,61,132],[67,62,133],[66,63,133],[66,64,134],[66,65,134],[65,66,135],[65,68,135],[64,69,136],[64,70,136],[63,71,136],[63,72,137],[62,73,137],[62,74,137],[62,76,138],[61,77,138],[61,78,138],[60,79,138],[60,80,139],[59,81,139],[59,82,139],[58,83,139],[58,84,140],[57,85,140],[57,86,140],[56,88,140],[56,89,140],[55,90,140],[55,91,141],[54,92,141],[54,93,141],[53,94,141],[53,95,141],[52,96,141],[52,97,141],[51,98,141],[51,99,141],[50,100,142],[50,101,142],[49,102,142],[49,103,142],[49,104,142],[48,105,142],[48,106,142],[47,107,142],[47,108,142],[46,109,142],[46,110,142],[46,111,142],[45,112,142],[45,113,142],[44,113,142],[44,114,142],[44,115,142],[43,116,142],[43,117,142],[42,118,142],[42,119,142],[42,120,142],[41,121,142],[41,122,142],[41,123,142],[40,124,142],[40,125,142],[39,126,142],[39,127,142],[39,128,142],[38,129,142],[38,130,142],[38,130,142],[37,131,142],[37,132,142],[37,133,142],[36,134,142],[36,135,142],[35,136,142],[35,137,142],[35,138,141],[34,139,141],[34,140,141],[34,141,141],[33,142,141],[33,143,141],[33,144,141],[33,145,140],[32,146,140],[32,146,140],[32,147,140],[31,148,140],[31,149,139],[31,150,139],[31,151,139],[31,152,139],[31,153,138],[31,154,138],[30,155,138],[30,156,137],[30,157,137],[31,158,137],[31,159,136],[31,160,136],[31,161,136],[31,161,135],[31,162,135],[32,163,134],[32,164,134],[33,165,133],[33,166,133],[34,167,133],[34,168,132],[35,169,131],[36,170,131],[37,171,130],[37,172,130],[38,173,129],[39,173,129],[40,174,128],[41,175,127],[42,176,127],[44,177,126],[45,178,125],[46,179,124],[47,180,124],[49,181,123],[50,182,122],[52,182,121],[53,183,121],[55,184,120],[56,185,119],[58,186,118],[59,187,117],[61,188,116],[63,188,115],[64,189,114],[66,190,113],[68,191,112],[70,192,111],[72,193,110],[74,193,109],[76,194,108],[78,195,107],[80,196,106],[82,197,105],[84,197,104],[86,198,103],[88,199,101],[90,200,100],[92,200,99],[94,201,98],[96,202,96],[99,203,95],[101,203,94],[103,204,92],[105,205,91],[108,205,90],[110,206,88],[112,207,87],[115,208,86],[117,208,84],[119,209,83],[122,209,81],[124,210,80],[127,211,78],[129,211,77],[132,212,75],[134,213,73],[137,213,72],[139,214,70],[142,214,69],[144,215,67],[147,215,65],[149,216,64],[152,216,62],[155,217,60],[157,217,59],[160,218,57],[162,218,55],[165,219,54],[168,219,52],[170,220,50],[173,220,48],[176,221,47],[178,221,45],[181,222,43],[184,222,41],[186,222,40],[189,223,38],[192,223,37],[194,223,35],[197,224,33],[200,224,32],[202,225,31],[205,225,29],[208,225,28],[210,226,27],[213,226,26],[216,226,25],[218,227,25],[221,227,24],[223,227,24],[226,228,24],[229,228,25],[231,228,25],[234,229,26],[236,229,27],[239,229,28],[241,229,29],[244,230,30],[246,230,32],[248,230,33],[251,231,35],[253,231,37]];

    // Convert 2D array to image data URL
    function arrayToImageSrc(array2d, colormap = 'gray', minVal = null, maxVal = null) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const height = array2d.length;
        const width = array2d[0].length;
        canvas.width = width;
        canvas.height = height;
        
        const imageData = ctx.createImageData(width, height);
        
        // Find min/max for normalization
        let min = minVal !== null ? minVal : Infinity;
        let max = maxVal !== null ? maxVal : -Infinity;
        
        if (minVal === null || maxVal === null) {
            // Auto-calculate min/max
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    min = Math.min(min, array2d[y][x]);
                    max = Math.max(max, array2d[y][x]);
                }
            }
        }
        
        // Apply colormap
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const normalized = (array2d[y][x] - min) / (max - min);
                const index = (y * width + x) * 4;
                
                if (colormap === 'viridis') {
                    // Map to viridis colormap
                    const colorIndex = Math.floor(normalized * 255);
                    const clampedIndex = Math.max(0, Math.min(255, colorIndex));
                    const [r, g, b] = viridisColors[clampedIndex];
                    imageData.data[index] = r;
                    imageData.data[index + 1] = g;
                    imageData.data[index + 2] = b;
                    imageData.data[index + 3] = 255;
                } else {
                    // Default grayscale
                    const grayValue = normalized * 255;
                    imageData.data[index] = grayValue;
                    imageData.data[index + 1] = grayValue;
                    imageData.data[index + 2] = grayValue;
                    imageData.data[index + 3] = 255;
                }
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas.toDataURL('image/png');
    }

    // Initialize Chart.js
    function initializeChart() {
      const ctx = document.getElementById('signalChart').getContext('2d');
      
      // Initial data (will be updated when mouse moves)
      const initialData = TE_vals.map(te => ({ x: te, y: 0 }));
      
      signalChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'Measured Signal',
            data: initialData,
            backgroundColor: 'rgba(54, 162, 235, 0.8)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6,
            showLine: true,
            tension: 0
          },
          {
            label: 'NLLS Fit',
            data: [],
            backgroundColor: 'rgba(255, 0, 0, 0)',
            borderColor: 'rgba(255, 0, 0, 1)',
            borderWidth: 1,
            pointRadius: 0,
            showLine: true,
            tension: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 1.33,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                usePointStyle: true,
                generateLabels: function(chart) {
                  const datasets = chart.data.datasets;
                  return datasets.map((dataset, i) => {
                    return {
                      text: dataset.label,
                      fillStyle: dataset.borderColor,
                      strokeStyle: dataset.borderColor,
                      lineWidth: dataset.borderWidth,
                      pointStyle: i === 0 ? 'circle' : 'line',
                      hidden: !chart.isDatasetVisible(i),
                      datasetIndex: i
                    };
                  });
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `TE: ${context.parsed.x.toFixed(1)} ms, Signal: ${context.parsed.y.toFixed(4)}`;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              title: {
                display: true,
                text: 'TE (ms)',
                font: { size: 14, weight: 'bold' }
              },
              min: 0,
              max: 150,
              ticks: {
                stepSize: 25
              },
              grid: { display: true, color: 'rgba(0, 0, 0, 0.1)' }
            },
            y: {
              title: {
                display: true,
                text: 'Signal Intensity (arbitrary units)',
                font: { size: 14, weight: 'bold' }
              },
              grid: { display: true, color: 'rgba(0, 0, 0, 0.1)' },
              beginAtZero: true,
              min: 0,
              max: 1.0
            }
          }
        }
      });
    }

    // Update chart with new pixel data
    function updateChart(imgX, imgY) {
      if (!signalChart || currentImageArrays.length === 0 || 
          imgX < 0 || imgY < 0 || 
          imgX >= imageWidth || imgY >= imageHeight) {
        return;
      }
      
      // Extract values at coordinates from all image series
      const newData = TE_vals.map((te, idx) => {
        if (idx < currentImageArrays.length && 
            imgY < currentImageArrays[idx].length && 
            imgX < currentImageArrays[idx][imgY].length) {
          return { x: te, y: currentImageArrays[idx][imgY][imgX] };
        }
        return { x: te, y: 0 };
      });
      
      // Get current dataset images for S0 and T values
      const images = getImageData(currentDatasetKey);
      
      // Generate fit curve data
      const fitData = [];
      if (images && images.label_S0 && images.label_T) {
        const s0Value = getPixelValue(images.label_S0, imgX, imgY);
        const tValue = getPixelValue(images.label_T, imgX, imgY);
        
        if (s0Value !== null && tValue !== null) {
          const TEmax = Math.max(...TE_vals); // 145.2
          
          // Generate 21 points from TE=0 to TE=150
          for (let i = 0; i <= 20; i++) {
            const te = i * 150 / 20; // 0, 7.5, 15, ..., 150
            const signal = s0Value * Math.exp(-te / (tValue * TEmax));
            fitData.push({ x: te, y: signal });
          }
        }
      }
      
      // Update chart data
      signalChart.data.datasets[0].data = newData;
      signalChart.data.datasets[1].data = fitData;
      signalChart.update('none');
      
      // Update chart title
      document.getElementById('chart-title').textContent = `Signal Decay Curve at Pixel (${imgX}, ${imgY})`;
    }

    // Handle mouse movement on parameter images
    function handleMouseMove(e, sourceWrapper, sourceImage, sourceCrosshair, sourceCoordDisplay, linkedCrosshair, linkedCoordDisplay, linkedImage) {
      const rect = sourceImage.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Convert to image pixel coordinates
      const imgX = Math.floor((x / rect.width) * imageWidth);
      const imgY = Math.floor((y / rect.height) * imageHeight);
      
      // Update source crosshair position
      const sourceVertical = sourceCrosshair.querySelector('.crosshair-vertical');
      const sourceHorizontal = sourceCrosshair.querySelector('.crosshair-horizontal');
      sourceVertical.style.left = x + 'px';
      sourceHorizontal.style.top = y + 'px';
      sourceCrosshair.style.display = 'block';
      
      // Update linked crosshair position
      const linkedRect = linkedImage.getBoundingClientRect();
      const linkedX = (imgX / imageWidth) * linkedRect.width;
      const linkedY = (imgY / imageHeight) * linkedRect.height;
      
      const linkedVertical = linkedCrosshair.querySelector('.crosshair-vertical');
      const linkedHorizontal = linkedCrosshair.querySelector('.crosshair-horizontal');
      linkedVertical.style.left = linkedX + 'px';
      linkedHorizontal.style.top = linkedY + 'px';
      linkedCrosshair.style.display = 'block';
      
      // Get current dataset images for pixel value lookup
      const images = getImageData(currentDatasetKey);
      

      // Optional display of coordinates and values below images. 
      const displayCoordinates = false;      
      if (displayCoordinates) {
        // Update coordinate displays with pixel coordinates and values
        const s0Display = document.getElementById('s0-coord-display');
        const tDisplay = document.getElementById('t-coord-display');

        if (s0Display && images && images.label_S0) {
          const s0Value = getPixelValue(images.label_S0, imgX, imgY);
          const s0Text = s0Value !== null ? 
            `(${imgX}, ${imgY}): ${s0Value.toFixed(2)}` : 
            `(${imgX}, ${imgY}): --`;
          s0Display.textContent = s0Text;
        }
        
        if (tDisplay && images && images.label_T) {
          const tValue = getPixelValue(images.label_T, imgX, imgY);
          const tText = tValue !== null ? 
            `(${imgX}, ${imgY}): ${tValue.toFixed(2)}` : 
            `(${imgX}, ${imgY}): --`;
          tDisplay.textContent = tText;
        }
      }

      // Update chart
      updateChart(imgX, imgY);
    }

    // Helper function for safe pixel access
    function getPixelValue(imageArray, x, y) {
      if (!imageArray || imageArray.length === 0 || 
          y < 0 || y >= imageArray.length || 
          x < 0 || x >= imageArray[0].length) {
        return null;
      }
      return imageArray[y][x];
    }

    // Set up mouse event listeners for interactive images
    function setupMouseListeners() {
      const s0Wrapper = document.getElementById('s0-param-wrapper');
      const s0Image = document.getElementById('s0-image');
      const s0Crosshair = document.getElementById('s0-crosshair');
      const s0CoordDisplay = document.getElementById('s0-coord-display');
      
      const tWrapper = document.getElementById('t-param-wrapper');
      const tImage = document.getElementById('t-image');
      const tCrosshair = document.getElementById('t-crosshair');
      const tCoordDisplay = document.getElementById('t-coord-display');
      
      if (s0Wrapper && tWrapper) {
        // S0 image mouse events
        s0Wrapper.addEventListener('mousemove', function(e) {
          handleMouseMove(e, s0Wrapper, s0Image, s0Crosshair, s0CoordDisplay, tCrosshair, tCoordDisplay, tImage);
        });
        
        s0Wrapper.addEventListener('mouseleave', function() {
          s0CoordDisplay.textContent = ' '; // Space placeholder to prevent layout shift
          tCoordDisplay.textContent = ' ';  // Space placeholder to prevent layout shift
          s0Crosshair.style.display = 'none';
          tCrosshair.style.display = 'none';
        });
        
        // T image mouse events
        tWrapper.addEventListener('mousemove', function(e) {
          handleMouseMove(e, tWrapper, tImage, tCrosshair, tCoordDisplay, s0Crosshair, s0CoordDisplay, s0Image);
        });
        
        tWrapper.addEventListener('mouseleave', function() {
          tCoordDisplay.textContent = ' '; // Space placeholder to prevent layout shift
          s0CoordDisplay.textContent = ' '; // Space placeholder to prevent layout shift
          tCrosshair.style.display = 'none';
          s0Crosshair.style.display = 'none';
        });
      }
    }

    // Process image series data for current dataset
    function processImageSeries(images) {
      currentImageArrays = [];
      
      // Directly use the array data (no decoding needed)
      for (let i = 0; i < 10; i++) {
        const imageKey = `image_${i}`;
        if (images[imageKey]) {
          currentImageArrays.push(images[imageKey]);
          
          // Set dimensions from first image
          if (i === 0) {
            imageHeight = images[imageKey].length;
            imageWidth = images[imageKey][0].length;
          }
        }
      }
    }

    // Function to update the content based on selected dataset
    async function updateContent(datasetKey) {
      currentDatasetKey = datasetKey;
      const config = datasetConfig[datasetKey];
      const images = getImageData(datasetKey);
      
      // Update text content
      document.getElementById('dataset-title').textContent = config.title;
      document.getElementById('dataset-description').textContent = config.description;
      document.getElementById('s0-subtitle').textContent = config.s0Subtitle;
      document.getElementById('t-subtitle').textContent = config.tSubtitle;
      document.getElementById('imageseries-title').textContent = config.imageseriesTitle;
      document.getElementById('details-text').textContent = config.detailsText;
      
      // Update arrow direction and text
      const arrowSymbol = document.getElementById('arrow-symbol');
      const arrowText = document.getElementById('arrow-text');
      arrowSymbol.textContent = config.arrowDirection === 'up' ? '↑' : '↓';
      arrowText.textContent = config.arrowText;
      
      const imagesContainer = document.getElementById('images-container');
      const noImagesMessage = document.getElementById('no-images-message');
      
      if (images) {
        // Show images container, hide no-images message
        imagesContainer.style.display = 'flex';
        noImagesMessage.style.display = 'none';
        
        // Define rendering parameters based on dataset
        let s0Colormap = 'gray';
        let tColormap = 'viridis';
        let s0Min = null, s0Max = null; // Auto-scale
        let tMin = null, tMax = null; // Auto-scale
        let imgMin = null; imgMax = null; // Auto-scale
        
        if (datasetKey === 'invivo') {
            // In vivo specific settings
            s0Min = 0; s0Max = 0.5;  
            tMin = 0; tMax = 2;    
            imgMin = 0; imgMax = 0.5;
        } // else keep defaults for synthetic datasets
        
        // Convert arrays to images and update S0 and T images
        const s0Image = document.getElementById('s0-image');
        const tImage = document.getElementById('t-image');
        
        if (images.label_S0) {
            s0Image.src = arrayToImageSrc(images.label_S0, s0Colormap, s0Min, s0Max);
            s0Image.alt = config.s0Alt;
        }
        
        if (images.label_T) {
            tImage.src = arrayToImageSrc(images.label_T, tColormap, tMin, tMax);
            tImage.alt = config.tAlt;
        }
        
        // Update image series grid images
        const imageseriesGrid = document.getElementById('imageseries-grid');
        imageseriesGrid.innerHTML = '';
        
        for (let i = 0; i < 10; i++) {
            const imageKey = `image_${i}`;
            if (images[imageKey]) {
                const img = document.createElement('img');
                img.src = arrayToImageSrc(images[imageKey], 'gray', imgMin, imgMax);
                img.alt = `${config.echoAltPrefix} ${i}`;
                imageseriesGrid.appendChild(img);
            }
        }
        
        // Update chart labels based on dataset type
        if (signalChart) {
          if (datasetKey === 'invivo') {
            signalChart.data.datasets[0].label = 'Measured Signal';
            signalChart.data.datasets[1].label = 'NLLS Fit';
          } else {
            signalChart.data.datasets[0].label = 'Synthetic Signal + noise';
            signalChart.data.datasets[1].label = 'Ground Truth';
          }
          signalChart.update('none');
        }
        
        // Process image series for interactive plotting (now synchronous)
        processImageSeries(images);
        
        // Setup mouse listeners after processing
        setTimeout(setupMouseListeners, 100);
      } else {
        // Show no-images message, hide images container
        noImagesMessage.style.display = 'block';
        imagesContainer.style.display = 'none';
      }
    }

    // Initial setup: chart and first dataset
    initializeChart();
    updateContent(currentDatasetKey);

    // Dataset tab navigation
    document.querySelectorAll('.tab-btn').forEach(button => {
      button.addEventListener('click', function() {
        const datasetKey = this.getAttribute('data-tab');
        
        // Update active tab
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        this.classList.add('active');
        
        // Update content for selected dataset
        updateContent(datasetKey);
      });
    });
    </script>
  </body>
</html>

