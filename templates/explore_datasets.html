<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Explore Datasets</title>
    <!-- Shared CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/shared.css') }}">
    <!-- Shared JavaScript -->
    <script src="{{ url_for('static', filename='js/shared.js') }}"></script>
    <!-- Chart.js for interactive plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
      /* Page-specific styles */
      body { 
        padding: 2rem;
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 { 
        margin-bottom: 1rem; 
        color: #333; 
      }

      
      /* Images Grid */
      .images-grid {
        display: flex;
        gap: 2rem;
        margin: 2rem auto;
        max-width: 1400px;
        align-items: start;
      }
      
      /* Left side containers */
      .left-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }
      
      /* Maps container for S0 and T images */
      .maps-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.2rem;
      }
      
      /* Plot container for chart */
      .plot-container {
        flex: 1;
        background: #ffffff;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        min-height: 400px;
        padding: 1rem;
      }
      
      .chart-title {
        text-align: center;
        font-weight: bold;
        color: #555;
        margin-bottom: 1rem;
        font-size: 1.1em;
      }
      
      /* Detailed text container */
      .details-container {
        flex: 1;
        background: #d1d5db;
        border-radius: 8px;
        padding: 0.5rem;
        margin-top: 1rem;
        line-height: 1.6;
        color: #555;
      }
      
      /* Arrow container for process indication */
      .arrow-container {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        padding: 0.00rem 0;
        gap: 0.75rem;
      }
      
      .arrow-container .arrow {
        font-size: 3rem;
        font-weight: 900;
        color: var(--accent);
        line-height: 1;
      }
      
      .arrow-container .arrow-text {
        font-size: 0.9rem;
        font-weight: bold;
        color: var(--accent);
        letter-spacing: 0.5px;
      }
      .image-container {
        text-align: center;
      }
      .image-container img {
        width: var(--parameter-map-size);
        height: var(--parameter-map-size);
        border: 1px solid #ddd;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .image-title {
        margin: 0.5rem 0;
        font-weight: bold;
        color: #555;
      }
      
      /* Interactive image wrapper and crosshairs */
      .image-wrapper {
        position: relative;
        display: block;
        width: var(--parameter-map-size);
        cursor: none;
        margin: 0 auto;
      }
      .image-wrapper img {
        display: block;
        width: var(--parameter-map-size);
        height: var(--parameter-map-size);
        border-radius: 6px;
      }
      .crosshair-overlay {
        position: absolute;
        pointer-events: none;
        display: none;
        z-index: 10;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
      }
      .crosshair-vertical {
        position: absolute;
        width: 1px;
        height: 100%;
        background-color: red;
        left: 50%;
      }
      .crosshair-horizontal {
        position: absolute;
        width: 100%;
        height: 1px;
        background-color: red;
        top: 50%;
      }
      .coord-display {
        text-align: center;
        font-size: 0.85em;
        color: #666;
        margin-top: 0.5rem;
        min-height: 1.2em;
      }
      .imageseries-container {
        text-align: center;
      }
      .imageseries-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 0.3rem;
      }
      .imageseries-grid img {
        width: 100%;
        height: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }
      .imageseries-grid-title {
        text-align: center;
        font-weight: bold;
        color: #555;
        margin-bottom: 0.5rem;
        font-size: 0.95em;
      }
      
      /* Page-specific responsive styles */
      @media (max-width: 768px) {
        .images-grid {
          flex-direction: column;
          gap: 1rem;
        }
        .maps-container {
          grid-template-columns: 1fr;
        }
        .plot-container {
          min-height: 200px;
        }
      }
    </style>
  </head>
  <body>
    <a href="/" class="back-link">← Back to Home</a>
    
    <h1>Explore Datasets</h1>
    
    <div class="info-box">
      <p>This page provides an interactive display for exploring the three kinds of datasets shown in 
        <a href="https://link.springer.com/article/10.1007/s10334-024-01186-3/figures/1">Figure 1</a> 
        of the paper. Click the tabs below to explore all three.</p>   
    </div>

    <div class="tab-container">
      <!-- Tab Navigation -->
      <ul class="tab-nav">
        <li><button class="tab-btn active" data-tab="invivo">In Vivo Dataset</button></li>
        <li><button class="tab-btn" data-tab="imagenet">ImageNet Synthetic</button></li>
        <li><button class="tab-btn" data-tab="random">Random Synthetic</button></li>
      </ul>

      <!-- Tab Content: Single Dynamic Template -->
      <div class="tab-content active" id="dynamic-content">
        <div class="tab-card">
          <div class="tab-description">
            <p id="tab-description"><!-- Dynamic Description --></p>
          </div>
          
          <div class="images-grid" id="images-container" style="display: none;">
            <div class="left-container">
              <div class="maps-container">
                <div class="image-container">
                  <div class="image-title">
                    <div style="font-size: 1.1em;">$S_0$ Parameter Map</div>
                    <div style="font-size: 0.9em;" id="s0-subtitle"><!-- Dynamic Subtitle --></div>
                  </div>
                  <div class="image-wrapper" id="s0-param-wrapper">
                    <img id="s0-image" src="" alt="">
                    <div class="crosshair-overlay" id="s0-crosshair">
                      <div class="crosshair-vertical"></div>
                      <div class="crosshair-horizontal"></div>
                    </div>
                  </div>
                </div>
                
                <div class="image-container">
                  <div class="image-title">
                    <div style="font-size: 1.1em;">$T_2$ Parameter Map</div>
                    <div style="font-size: 0.9em;" id="t-subtitle"><!-- Dynamic Subtitle --></div>
                  </div>
                  <div class="image-wrapper" id="t-param-wrapper">
                    <img id="t-image" src="" alt="">
                    <div class="crosshair-overlay" id="t-crosshair">
                      <div class="crosshair-vertical"></div>
                      <div class="crosshair-horizontal"></div>
                    </div>
                  </div>
                </div>
                </div>

                <div class="arrow-container">
                  <div class="arrow" id="arrow-symbol"><!-- Dynamic Arrow --></div>
                  <div class="arrow-text" id="arrow-text"><!-- Dynamic Text --></div>
                </div>

              <div class="imageseries-container">
                <div class="imageseries-grid-title" id="imageseries-title"><!-- Dynamic Image Series Title --></div>
                <div class="imageseries-grid" id="imageseries-grid">
                  <!-- Dynamic echo images -->
                </div>
              </div>
            </div>
            
            <div style="flex: 1; display: flex; flex-direction: column;">
              <div class="plot-container">
                <div class="chart-title" id="chart-title">Signal Decay Curve at Pixel (50, 50)</div>
                <canvas id="signalChart"></canvas>
              </div>
              
              <div class="details-container">
                <p id="details-text">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
              </div>
            </div>
          </div>
          
          <p id="no-images-message" style="text-align: center; color: #666; display: none;">Images not available.</p>
        </div>
      </div>
    </div>

    <!-- Image data injection -->
    <script id="invivo-data" type="application/json">{% if invivo_imageset %}{{ invivo_imageset | tojson | safe }}{% else %}null{% endif %}</script>
    <script id="imagenet-data" type="application/json">{% if imagenet_imageset %}{{ imagenet_imageset | tojson | safe }}{% else %}null{% endif %}</script>
    <script id="random-data" type="application/json">{% if urand_imageset %}{{ urand_imageset | tojson | safe }}{% else %}null{% endif %}</script>
    <script id="te-vals-data" type="application/json">{% if TE_vals %}{{ TE_vals | tojson | safe }}{% else %}null{% endif %}</script>

    <script>
    // Load TE values
    const TE_vals = JSON.parse(document.getElementById('te-vals-data').textContent) || [26.4, 39.6, 52.8, 66.0, 79.2, 92.4, 105.6, 118.8, 132.0, 145.2];
    
    // Dataset configuration
    const datasetConfig = {
      invivo: {
        title: 'In Vivo Dataset', // Not used
        description: `This is an example of a single slice from an <i>in vivo</i> $T_2$ measurement. The standard approach is 
          to use curve fitting to produce the $T_2$ map, which can then be used for human interpretation diagnosis and/or 
          cancer prediction models.`,
        s0Subtitle: '(from NLLS fit)',
        tSubtitle: '(from NLLS fit)',
        imageseriesTitle: 'Measured Multi-Echo Image Series',
        s0Alt: 'In Vivo S0',
        tAlt: 'In Vivo T2',
        echoAltPrefix: 'Echo',
        arrowDirection: 'up',
        arrowText: 'NLLS Curve Fitting',
        detailsText: `The same slice is measured at ten different echo times (lower left) with signal progressively 
          decreasing. Each pixel is fit using a non-linear least squares (NLLS) method to the equation 
          $S(TE) = S_0 \\exp(-TE/T_2)$. The resulting maps for $S_0$ and $T_2$ are shown on the upper left. Dragging your mouse over 
          these maps shows the signal and fit for each pixel in the images.`
      },
      imagenet: {
        title: 'ImageNet Synthetic Dataset',
        description: `This is an example of a synthetic dataset. A novel aspect of this paper is the generation of a large amount 
          of synthetic imaging data for supervised training.`,
        s0Subtitle: 'Ground Truth',
        tSubtitle: 'Ground Truth',
        imageseriesTitle: 'Synthetic Multi-Echo Image Series',
        s0Alt: 'ImageNet S0',
        tAlt: 'ImageNet T2',
        echoAltPrefix: 'Synth',
        arrowDirection: 'down',
        arrowText: 'Synthesize w/noise',
        detailsText: `To synthesize data, random images were selected from a public image dataset 
          (<a href="https://www.image-net.org/">ImageNet</a>) and used to represent 
          ground truth parameter maps S0 and T2. From these, a multi-echo image series was synthesized using the same 
          equation ($S(TE) = S_0 \\exp(-TE/T_2)$) and by adding noise to the images following the physics of MR image 
          generation (i.e., Rician noise).
          <p>The networks were trained using 10,000 synthetic image sets with random images and variable noise levels. In this way 
          the networks do not learn about prostates, or elephants and dogs, rather they learn the physical equation  and how to accurately 
          generate the parameter maps $S_0$ and $T_2$  from the noisy images $S(TE)$.`
      },
      random: {
        title: 'Random Synthetic Dataset',
        description: `This is also an example of synthetic dataset, but generated from parametric maps of randomly generated uniform noise 
          rather than images from ImageNet.`,
        s0Subtitle: 'Ground Truth',
        tSubtitle: 'Ground Truth',
        imageseriesTitle: 'Synthetic Multi-Echo Image Series',
        s0Alt: 'Random S0',
        tAlt: 'Random T2',
        echoAltPrefix: 'Random',
        arrowDirection: 'down',
        arrowText: 'Synthesize w/noise',
        detailsText: `This dataset is generated in exactly the same way as the ImageNet synthetic dataset, by modeling 
        the exponential decay and adding physics-guided noise. This dataset was used to explore how CNNs perform 
        denoising. In the ImageNet data, pixel values are somewhat correlated with neighboring pixels, and this 
        information can help estimating parameters in noisy data. Models trained using these purely random images 
        were expected to provide poorer denoising performance because they cannot exploit spatial correlation 
        between neighboring pixels.`
      }
    };

    // Global variables for chart and current dataset
    let signalChart = null;
    let currentDatasetKey = 'invivo';
    let currentImageArrays = [];
    let imageWidth = 0;
    let imageHeight = 0;

    // Load image data from script tags
    function getImageData(datasetKey) {
      const scriptId = `${datasetKey}-data`;
      const script = document.getElementById(scriptId);
      if (script && script.textContent.trim() !== 'null') {
        return JSON.parse(script.textContent);
      }
      return null;
    }

    // Initialize Chart.js
    function initializeChart() {
      const ctx = document.getElementById('signalChart').getContext('2d');
      
      // Initial data (will be updated when mouse moves)
      const initialData = TE_vals.map(te => ({ x: te, y: 0 }));
      
      signalChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'Measured Signal',
            data: initialData,
            backgroundColor: 'rgba(54, 162, 235, 0.8)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6,
            showLine: true,
            tension: 0
          },
          {
            label: 'NLLS Fit',
            data: [],
            backgroundColor: 'rgba(255, 0, 0, 0)',
            borderColor: 'rgba(255, 0, 0, 1)',
            borderWidth: 1,
            pointRadius: 0,
            showLine: true,
            tension: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 1.33,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                usePointStyle: true,
                generateLabels: function(chart) {
                  const datasets = chart.data.datasets;
                  return datasets.map((dataset, i) => {
                    return {
                      text: dataset.label,
                      fillStyle: dataset.borderColor,
                      strokeStyle: dataset.borderColor,
                      lineWidth: dataset.borderWidth,
                      pointStyle: i === 0 ? 'circle' : 'line',
                      hidden: !chart.isDatasetVisible(i),
                      datasetIndex: i
                    };
                  });
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `TE: ${context.parsed.x.toFixed(1)} ms, Signal: ${context.parsed.y.toFixed(4)}`;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              title: {
                display: true,
                text: 'Echo time TE (ms)',
                font: { size: 14, weight: 'bold' }
              },
              min: 0,
              max: 150,
              ticks: {
                stepSize: 25
              },
              grid: { display: true, color: 'rgba(0, 0, 0, 0.1)' }
            },
            y: {
              title: {
                display: true,
                text: 'Signal Intensity (arbitrary units)',
                font: { size: 14, weight: 'bold' }
              },
              grid: { display: true, color: 'rgba(0, 0, 0, 0.1)' },
              beginAtZero: true,
              min: 0,
              max: 1.0
            }
          }
        }
      });
    }

    // Update chart with new pixel data
    function updateChart(imgX, imgY) {
      if (!signalChart || currentImageArrays.length === 0 || 
          imgX < 0 || imgY < 0 || 
          imgX >= imageWidth || imgY >= imageHeight) {
        return;
      }
      
      // Extract values at coordinates from all image series
      const newData = TE_vals.map((te, idx) => {
        if (idx < currentImageArrays.length && 
            imgY < currentImageArrays[idx].length && 
            imgX < currentImageArrays[idx][imgY].length) {
          return { x: te, y: currentImageArrays[idx][imgY][imgX] };
        }
        return { x: te, y: 0 };
      });
      
      // Get current dataset images for S0 and T values
      const images = getImageData(currentDatasetKey);
      
      // Generate fit curve data
      const fitData = [];
      if (images && images.label_S0 && images.label_T) {
        const s0Value = getPixelValue(images.label_S0, imgX, imgY);
        const tValue = getPixelValue(images.label_T, imgX, imgY);
        
        if (s0Value !== null && tValue !== null) {
          const TEmax = Math.max(...TE_vals); // 145.2
          
          // Generate 21 points from TE=0 to TE=150
          for (let i = 0; i <= 20; i++) {
            const te = i * 150 / 20; // 0, 7.5, 15, ..., 150
            const signal = s0Value * Math.exp(-te / (tValue * TEmax));
            fitData.push({ x: te, y: signal });
          }
        }
      }
      
      // Update chart data
      signalChart.data.datasets[0].data = newData;
      signalChart.data.datasets[1].data = fitData;
      signalChart.update('none');
      
      // Update chart title
      document.getElementById('chart-title').textContent = `Signal Decay Curve at Pixel (${imgX}, ${imgY})`;
    }

    // Handle mouse movement on parameter images
    function handleMouseMove(e, sourceWrapper, sourceImage, sourceCrosshair, linkedCrosshair, linkedImage) {
      const rect = sourceImage.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Convert to image pixel coordinates
      const imgX = Math.floor((x / rect.width) * imageWidth);
      const imgY = Math.floor((y / rect.height) * imageHeight);
      
      // Update source crosshair position
      const sourceVertical = sourceCrosshair.querySelector('.crosshair-vertical');
      const sourceHorizontal = sourceCrosshair.querySelector('.crosshair-horizontal');
      sourceVertical.style.left = x + 'px';
      sourceHorizontal.style.top = y + 'px';
      sourceCrosshair.style.display = 'block';
      
      // Update linked crosshair position
      const linkedRect = linkedImage.getBoundingClientRect();
      const linkedX = (imgX / imageWidth) * linkedRect.width;
      const linkedY = (imgY / imageHeight) * linkedRect.height;
      
      const linkedVertical = linkedCrosshair.querySelector('.crosshair-vertical');
      const linkedHorizontal = linkedCrosshair.querySelector('.crosshair-horizontal');
      linkedVertical.style.left = linkedX + 'px';
      linkedHorizontal.style.top = linkedY + 'px';
      linkedCrosshair.style.display = 'block';
      
      // Get current dataset images for pixel value lookup
      const images = getImageData(currentDatasetKey);
      

      // Update chart
      updateChart(imgX, imgY);
    }

    // Helper function for safe pixel access
    function getPixelValue(imageArray, x, y) {
      if (!imageArray || imageArray.length === 0 || 
          y < 0 || y >= imageArray.length || 
          x < 0 || x >= imageArray[0].length) {
        return null;
      }
      return imageArray[y][x];
    }

    // Set up mouse event listeners for interactive images
    function setupMouseListeners() {
      const s0Wrapper = document.getElementById('s0-param-wrapper');
      const s0Image = document.getElementById('s0-image');
      const s0Crosshair = document.getElementById('s0-crosshair');
      
      const tWrapper = document.getElementById('t-param-wrapper');
      const tImage = document.getElementById('t-image');
      const tCrosshair = document.getElementById('t-crosshair');
      
      if (s0Wrapper && tWrapper) {
        // S0 image mouse events
        s0Wrapper.addEventListener('mousemove', function(e) {
          handleMouseMove(e, s0Wrapper, s0Image, s0Crosshair, tCrosshair, tImage);
        });
        
        s0Wrapper.addEventListener('mouseleave', function() {
          s0Crosshair.style.display = 'none';
          tCrosshair.style.display = 'none';
        });
        
        // T image mouse events
        tWrapper.addEventListener('mousemove', function(e) {
          handleMouseMove(e, tWrapper, tImage, tCrosshair, s0Crosshair, s0Image);
        });
        
        tWrapper.addEventListener('mouseleave', function() {
          tCrosshair.style.display = 'none';
          s0Crosshair.style.display = 'none';
        });
      }
    }

    // Process image series data for current dataset
    function processImageSeries(images) {
      currentImageArrays = [];
      
      // Directly use the array data (no decoding needed)
      for (let i = 0; i < 10; i++) {
        const imageKey = `image_${i}`;
        if (images[imageKey]) {
          currentImageArrays.push(images[imageKey]);
          
          // Set dimensions from first image
          if (i === 0) {
            imageHeight = images[imageKey].length;
            imageWidth = images[imageKey][0].length;
          }
        }
      }
    }

    // Function to update the content based on selected dataset
    async function updateContent(datasetKey) {
      currentDatasetKey = datasetKey;
      const config = datasetConfig[datasetKey];
      const images = getImageData(datasetKey);
      
            // Update text content
      document.getElementById('tab-description').innerHTML = config.description;
      document.getElementById('s0-subtitle').innerHTML = config.s0Subtitle;
      document.getElementById('t-subtitle').innerHTML = config.tSubtitle;
      document.getElementById('imageseries-title').innerHTML = config.imageseriesTitle;
      document.getElementById('details-text').innerHTML = config.detailsText;
      
      // Update arrow direction and text
      const arrowSymbol = document.getElementById('arrow-symbol');
      const arrowText = document.getElementById('arrow-text');
      arrowSymbol.textContent = config.arrowDirection === 'up' ? '↑' : '↓';
      arrowText.textContent = config.arrowText;
      
      const imagesContainer = document.getElementById('images-container');
      const noImagesMessage = document.getElementById('no-images-message');
      
      if (images) {
        // Show images container, hide no-images message
        imagesContainer.style.display = 'flex';
        noImagesMessage.style.display = 'none';
        
        // Define rendering parameters based on dataset
        let s0Colormap = 'gray';
        let tColormap = 'viridis';
        let s0Min = 0, s0Max = 1;
        let tMin = 0, tMax = 4; 
        let imgMin = 0; imgMax = 1; 
        
        if (datasetKey === 'invivo') {
            // In vivo specific settings
            s0Min = 0; s0Max = 0.4;  
            tMin = 0; tMax = 2;    
            imgMin = 0; imgMax = 0.4;
        } // else keep defaults for synthetic datasets
        
        // Convert arrays to images and update S0 and T images
        const s0Image = document.getElementById('s0-image');
        const tImage = document.getElementById('t-image');
        
        if (images.label_S0) {
            s0Image.src = arrayToImageSrc(images.label_S0, s0Colormap, s0Min, s0Max);
            s0Image.alt = config.s0Alt;
        }
        
        if (images.label_T) {
            tImage.src = arrayToImageSrc(images.label_T, tColormap, tMin, tMax);
            tImage.alt = config.tAlt;
        }
        
        // Update image series grid images
        const imageseriesGrid = document.getElementById('imageseries-grid');
        imageseriesGrid.innerHTML = '';
        
        for (let i = 0; i < 10; i++) {
            const imageKey = `image_${i}`;
            if (images[imageKey]) {
                const img = document.createElement('img');
                img.src = arrayToImageSrc(images[imageKey], 'gray', imgMin, imgMax);
                img.alt = `${config.echoAltPrefix} ${i}`;
                imageseriesGrid.appendChild(img);
            }
        }
        
        // Update chart labels based on dataset type
        if (signalChart) {
          if (datasetKey === 'invivo') {
            signalChart.data.datasets[0].label = 'Measured Signal';
            signalChart.data.datasets[1].label = 'NLLS Fit';
            signalChart.options.scales.y.max = 0.5;
          } else {
            signalChart.data.datasets[0].label = 'Synthetic Signal + noise';
            signalChart.data.datasets[1].label = 'Ground Truth';
            signalChart.options.scales.y.max = 1.0;
          }
          signalChart.update('none');
        }
        
        // Process image series for interactive plotting (now synchronous)
        processImageSeries(images);
        
        // Setup mouse listeners after processing
        setTimeout(setupMouseListeners, 100);
      } else {
        // Show no-images message, hide images container
        noImagesMessage.style.display = 'block';
        imagesContainer.style.display = 'none';
      }
    }

    // Initial setup: chart and first dataset
    initializeChart();
    updateContent(currentDatasetKey);

    // Dataset tab navigation
    document.querySelectorAll('.tab-btn').forEach(button => {
      button.addEventListener('click', function() {
        const datasetKey = this.getAttribute('data-tab');
        
        // Update active tab
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        this.classList.add('active');
        
        // Update content for selected dataset
        updateContent(datasetKey);
        
        // Re-render math after content update
        if (window.renderMathInElement) {
          renderMathInElement(document.body, {
            delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false}
            ]
          });
        }
      });
    });
    
    // Initial math rendering after page load
    document.addEventListener('DOMContentLoaded', function() {
      if (window.renderMathInElement) {
        renderMathInElement(document.body, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false}
          ]
        });
      }
    });
    </script>
  </body>
</html>

